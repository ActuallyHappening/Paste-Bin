<!-- All scripts by Caleb Yates -->
<!-- SCROL DOWN -->
<html>
  <!-- SCROLL DOWN -->
  <head>
    <title>Class Case Study</title>
  </head>
  <!-- KEEP SCROLLING! -->
  <body>
    <script>
      // DOWN, your almost there!
      sqrt = Math.sqrt;
      square_root = sqrt
      squareroot = sqrt
      squareRoot = sqrt
      studentAttempt = function(x1, y1, z1, x2, y2, z2) {
        // Keep scrolling
        
        let length_of_first_vector = 69 // DONT touch this line!
        let length_of_second_vector = 420 // DONT touch this line either!
        // Set your own answer under **here** below!
        
        // How to set your answer:
        length_of_first_vector = 123456
        length_of_first_vector = 69696969
        length_of_second_vector = 420420420

        /*
          To multiply: x * y
          To divide: x / y
          To add: x + y
          To subtract: x - y
          To square root (hint hint!): sqrt(x)
        */
        // e.g.
        sqrt(69);
        69 * 420;
        69 - 420;
        69 / 420;
        69 + 420;

        // More sqrt:
        sqrt(69696969);
        sqrt(x1);
        sqrt(y2);
        sqrt(z1);
        // etc.
        
        // e.g.
        length_of_first_vector = sqrt(42069);
        length_of_second_vector = 69 * 420;
        length_of_first_vector = 69 - 420;
        length_of_second_vector = x2 / 420; // Use variables wherever you like
        length_of_first_vector = 69 + z1;
        
        /* THE TASK

          1. Find a formula for the length (magnitude) of the first and second 3D vectors.
          2. Write this formula in code (helpful examples above) like:
              length_of_first_vector = sqrt(... * ... + ... / whatever you want here its math)
          3. Open the document (or reload) and see the planet properly!

        */
        /**************** HERE ***************/

        length_of_first_vector  = "*** DELETE THIS AND PUT HERE ***"
        length_of_second_vector = "*** DELETE THIS AND PUT HERE ***"
        
        /**************** STOP ***************/
        
        return length_of_first_vector > length_of_second_vector
        
      }
      </script>
    <main class="content content--fullscreen">
    <canvas id="THE-canvas"></canvas>
    </main>
    <!-- Put your code just above here -->
    <!-- DONT scroll down :) answers -->
    <script>
      // Answer:
      //length_of_first_vector = sqrt(x1 * x1 + y1 * y1 + z1 * z1);
      //length_of_second_vector = sqrt(x2 * x2 + y2 * y2 + z2 * z2);
    </script>
  
    <script type="module">
      // Actual code (just ignore :)
import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/loaders/GLTFLoader.js';
import { TrackballControls} from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/TrackballControls.js';

const canvas = document.querySelector('#THE-canvas');
const overlay = canvas.getContext('2d');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
    55, window.innerWidth / window.innerHeight, 1, 1500
);

const orbitalDistance = 100; // Changes distance of projects from center

let debugCounter = 0;

const numExtraProjects = 35

let projects;
  projects = [{
    name: 'Center',
    coords: { x: 0, y: 0, z: 0 },
    url: '/#',
  },];

function randomNum(range = 1) {
  return (Math.random()-0.5)*range*2
}

function generateRandomOrbitalVector(distance) {
  const vec = new THREE.Vector3(randomNum(distance), randomNum(distance), randomNum(distance))
  vec.project(camera)
  vec.setLength(distance)
  return vec
}

for (let i = 0; i < numExtraProjects; i++) {
  const orbit = generateRandomOrbitalVector(orbitalDistance)
  //console.log(orbit)
  projects.push({
    name: 'Moon: ' + i,
    coords: { x: orbit.x, y: orbit.y, z: orbit.z },
    url: '/#',
  })
  //projects[projects.length - 1].orbitalAxis = new THREE.Vector3(randomNum(1), randomNum(1), randomNum(1))
}

let group = new THREE.Group(); // MUST Sync with projects (not bothered to refactor at the moment)
let sunlight;
let renderer;
let controls;
let zoomLevel;
let markerPoints2D;

let planet; // Object for planet
let planetGraphics; // Group for loaded planet graphics

init();
animate();


/*
 * Initialise canvas
 */
function init() {
  window.addEventListener('resize', handleWindowResize, false);

  // Helpers
    scene.add(new THREE.GridHelper(1500, 100));
    scene.add(new THREE.AxesHelper(500));

  // Camera
  camera.position.x = 0;
  camera.position.y = 10;
  camera.position.z = 400;

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  canvas.insertAdjacentElement('afterend', renderer.domElement);

/*   // Planet object
  // Group globe and markers together
  const loader = new GLTFLoader();
  loader.load(
    'https://communityportal.io/assets/objects/low-poly-planet.gltf',
    object => {
      planetGraphics = object.scene
      scene.add(planetGraphics)
      if (shouldDebug) console.log("PlanetG added", planetGraphics)
    },
    xhr => console.log("Poly (planet) " + (xhr.loaded / xhr.total * 100 ) + '% loaded'),
    error => console.log('An error happened:', error),
  ); */

  let planetGeometry = new THREE.SphereGeometry(69) // HARDCODED just note it techniquely should scale from above graphics import (not bothered right now)
  let planetMaterial = new THREE.MeshPhysicalMaterial({color: 0x0000ff})
  planet = new THREE.Mesh(planetGeometry, planetMaterial)
  scene.add(planet)
  planet.visible = true
 

  // Lighting
  sunlight = new THREE.DirectionalLight(0xf0fff0, 3.5);
  sunlight.position.set(0, 0, 100);

  // Controls
  controls = new TrackballControls(camera, renderer.domElement);
  controls.minDistance = 250;
  controls.maxDistance = 1499;
  controls.rotateSpeed = 1.0;
  controls.zoomSpeed = 1.2;
  controls.panSpeed = 0.8;

  // Project markers
  projects.forEach((project, index) => {
    let html =
      `<div class="marker" id="project-${index + 1}">
				<a class="marker__label" href="${project?.url}">
					<strong>${project.name}</strong>
				</a>
				<div class="marker__pointer"></div>
			</div>`;

    let geometry = new THREE.SphereGeometry(10, 10, 10);
    let material = new THREE.MeshPhysicalMaterial({ color: 0x0000ff });
    let mesh = new THREE.Mesh(geometry, material);

    mesh.position.set(
      project.coords.x,
      project.coords.y,
      project.coords.z,
    );
    mesh.visible = true;
    group.add(mesh);

    canvas.insertAdjacentHTML('afterend', html);
    project.element = document.querySelector(`#project-${index + 1}`);
    project.mesh = mesh;
  });

  markerPoints2D = document.querySelectorAll('.marker__pointer');

  scene.background = new THREE.Color(0x07131C);
  scene.add(group, sunlight);
}


/*
 * Updates animation frame.
 */
function animate() {
    debugCounter++;
    zoomLevel = controls.target.distanceTo(controls.object.position);
    //console.log(controls.object.position) // 'Camera' position
    const axis = new THREE.Vector3(0, 1, 0) // Y axis to revolve around
    
    /********************* NEW ****************** */
    const increase = 0.01; // Rotates by this amount
    group.children.forEach((projectRef, index) => {
      projectRef.position.applyAxisAngle(projects[index]?.orbitalAxis ?? axis, increase); // Apply rotation to each individual project point
    })
    if (planetGraphics) planetGraphics.rotation.y += increase;
    //group.rotation.y += 0.005; // ********* OLD BUGGY LINE ************

    controls.update();
    renderer.render(scene, camera);
    //group.updateMatrixWorld; // Don't know what that was there!
    updateMarkerSizes();
    updateMarkerPositions();
    requestAnimationFrame(animate);
}


/*
 * Recalculate canvas upon resize.
 */
function handleWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}


/*
 * Update marker based on camera zoom.
 */
function updateMarkerSizes() {
    const markerScaleMin = 0.3;

    let markerScale;
    let percentage = 100 - (
        (zoomLevel - controls.minDistance) /
        (controls.maxDistance - controls.minDistance) *
        100
    );

    percentage = Math.min(Math.max(percentage, 0), 100);
    markerScale = markerScaleMin + Math.pow(0.0095 * percentage, 2);

    markerPoints2D.forEach(marker => {
        marker.style.setProperty('--scale', markerScale);
    });
}


function getRealPixelsTopLeft(vector, aCamera) {
  vector = vector.clone()
  vector.project(aCamera)
  vector.x = Math.round((0.5 + vector.x / 2) * (renderer.domElement.width / window.devicePixelRatio));
  vector.y = Math.round((0.5 - vector.y / 2) * (renderer.domElement.height / window.devicePixelRatio));
  return vector
}

/*
 * Update hotspot positions.
 */
function updateMarkerPositions() {
    const axis = new THREE.Vector3(0, 1, 0); // Y axis

    projects.forEach((project, index) => {

      let vector = group.children[index].position.clone()
      vector.project(camera);
      const point = vector.clone()

      vector.x = Math.round((0.5 + vector.x / 2) * (renderer.domElement.width / window.devicePixelRatio));
      vector.y = Math.round((0.5 - vector.y / 2) * (renderer.domElement.height / window.devicePixelRatio));

      project.element.style.top = `${vector.y}px`;
      project.element.style.left = `${vector.x}px`;

      let should = false; // Whether the project point is behind or not

      const raycaster = new THREE.Raycaster()
      raycaster.setFromCamera(point, camera);
      const intersects = raycaster.intersectObjects(scene.children)
      //if (debugCounter % 1000 == 69) console.log(intersects)
      let seenSelf = false;
      intersects.forEach((intersect, i) => {
        if (intersect.object == project.mesh) seenSelf = true
        if (intersect.object == planet) {
          //console.log("Planet spotted ...")
          if (seenSelf);//console.log("INFRONT!")
          else {
            //console.log("BEHIND")
            should = true
          }
        }
      })

      project.mesh.visible = true;
      if (should) {
        project.mesh.material.color.set(0x00ff00);
      } else {
        project.mesh.material.color.set(0xff0000);
      }

      /* project.element.classList.toggle(
          'is-behind',
          should
      ); */
      //console.log(project.point.position);
    });
}
    </script>
    <style>
      .content--fullscreen{
	height:100%;
	position:fixed;
	right:0;
	top:0;
	width:100%
}
.content--fullscreen>canvas{
	cursor:-webkit-grab;
	cursor:grab;
	position:fixed;
	right:0;
	top:0;
	z-index:0
}
.content--fullscreen>canvas:active{
	cursor:-webkit-grabbing;
	cursor:grabbing
}
.marker{
	left:0;
	pointer-events:none;
	position:absolute;
	top:0
}
.marker__label{
	-webkit-box-align:center;
	-ms-flex-align:center;
	align-items:center;
	-webkit-backdrop-filter:blur(2px);
	backdrop-filter:blur(2px);
	background-color:rgba(51,51,51,.6);
	border:2px solid #07131c;
	border-radius:.5rem;
	bottom:.875rem;
	color:#ebebeb;
	display:-webkit-box;
	display:-ms-flexbox;
	display:flex;
	opacity:0;
	padding:.5rem 1.25rem;
	pointer-events:none;
	position:absolute;
	-webkit-transform:translateX(-50%);
	transform:translateX(-50%);
	-webkit-transition:opacity 225ms ease-in-out;
	transition:opacity 225ms ease-in-out;
	white-space:nowrap;
	z-index:2
}
.marker:hover>.marker__label,.marker:focus-within>.marker__label{
	opacity:1;
	pointer-events:all
}
.marker__pointer{
	--scale: 1;
	cursor:pointer;
	height:3.25rem;
	pointer-events:all;
	position:absolute;
	-webkit-transform:translate(-50%, -50%);
	transform:translate(-50%, -50%);
	-webkit-transition:opacity 500ms ease-in-out;
	transition:opacity 500ms ease-in-out;
	width:3.25rem;
	z-index:1
}
.marker__pointer::before{
	border-radius:50%;
	content:"";
	display:block;
	height:100%;
	position:absolute;
	width:100%
}
.marker__pointer::before{
	-webkit-animation:pulse 4s ease-out infinite;
	animation:pulse 4s ease-out infinite;
	-webkit-animation-fill-mode:both;
	animation-fill-mode:both;
	border:2px solid #ebebeb;
	-webkit-box-sizing:border-box;
	box-sizing:border-box
}
    </style>
  </body>
</html>
